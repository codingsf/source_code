// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ME.Interface.proto

#ifndef PROTOBUF_ME_2eInterface_2eproto__INCLUDED
#define PROTOBUF_ME_2eInterface_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "ME.Auth.pb.h"
#include "ME.OrderAPI.pb.h"
#include "ME.MESubcribeAPI.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_ME_2eInterface_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[1];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsIntervalMsgHeaderImpl();
void InitDefaultsIntervalMsgHeader();
inline void InitDefaults() {
  InitDefaultsIntervalMsgHeader();
}
}  // namespace protobuf_ME_2eInterface_2eproto
namespace MEProInterface {
class IntervalMsgHeader;
class IntervalMsgHeaderDefaultTypeInternal;
extern IntervalMsgHeaderDefaultTypeInternal _IntervalMsgHeader_default_instance_;
}  // namespace MEProInterface
namespace MEProInterface {

// ===================================================================

class IntervalMsgHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MEProInterface.IntervalMsgHeader) */ {
 public:
  IntervalMsgHeader();
  virtual ~IntervalMsgHeader();

  IntervalMsgHeader(const IntervalMsgHeader& from);

  inline IntervalMsgHeader& operator=(const IntervalMsgHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IntervalMsgHeader(IntervalMsgHeader&& from) noexcept
    : IntervalMsgHeader() {
    *this = ::std::move(from);
  }

  inline IntervalMsgHeader& operator=(IntervalMsgHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IntervalMsgHeader& default_instance();

  enum MsgBodyCase {
    kStUserLogin = 4,
    kStLoginResp = 5,
    kStSubmitOrder = 6,
    kStCancelOrder = 7,
    kStOrderResp = 8,
    kStQueryOrder = 9,
    kStQueryResp = 10,
    kStTransOrder = 11,
    kStMarketData = 12,
    kStReptransReq = 13,
    kStSubcriUserLogin = 14,
    kStQueryHistoryOrder = 15,
    MSGBODY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IntervalMsgHeader* internal_default_instance() {
    return reinterpret_cast<const IntervalMsgHeader*>(
               &_IntervalMsgHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(IntervalMsgHeader* other);
  friend void swap(IntervalMsgHeader& a, IntervalMsgHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IntervalMsgHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  IntervalMsgHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IntervalMsgHeader& from);
  void MergeFrom(const IntervalMsgHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IntervalMsgHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 iFlowNumber = 1;
  void clear_iflownumber();
  static const int kIFlowNumberFieldNumber = 1;
  ::google::protobuf::int32 iflownumber() const;
  void set_iflownumber(::google::protobuf::int32 value);

  // int32 iCmd = 2;
  void clear_icmd();
  static const int kICmdFieldNumber = 2;
  ::google::protobuf::int32 icmd() const;
  void set_icmd(::google::protobuf::int32 value);

  // int32 iMsgType = 3;
  void clear_imsgtype();
  static const int kIMsgTypeFieldNumber = 3;
  ::google::protobuf::int32 imsgtype() const;
  void set_imsgtype(::google::protobuf::int32 value);

  // .MEAuth.ST_USER_LOGIN_INFO stUserLogin = 4;
  bool has_stuserlogin() const;
  void clear_stuserlogin();
  static const int kStUserLoginFieldNumber = 4;
  const ::MEAuth::ST_USER_LOGIN_INFO& stuserlogin() const;
  ::MEAuth::ST_USER_LOGIN_INFO* release_stuserlogin();
  ::MEAuth::ST_USER_LOGIN_INFO* mutable_stuserlogin();
  void set_allocated_stuserlogin(::MEAuth::ST_USER_LOGIN_INFO* stuserlogin);

  // .MEAuth.ST_USER_LOGIN_RESP stLoginResp = 5;
  bool has_stloginresp() const;
  void clear_stloginresp();
  static const int kStLoginRespFieldNumber = 5;
  const ::MEAuth::ST_USER_LOGIN_RESP& stloginresp() const;
  ::MEAuth::ST_USER_LOGIN_RESP* release_stloginresp();
  ::MEAuth::ST_USER_LOGIN_RESP* mutable_stloginresp();
  void set_allocated_stloginresp(::MEAuth::ST_USER_LOGIN_RESP* stloginresp);

  // .MEOrderAPI.ST_SUBMIT_ORDER stSubmitOrder = 6;
  bool has_stsubmitorder() const;
  void clear_stsubmitorder();
  static const int kStSubmitOrderFieldNumber = 6;
  const ::MEOrderAPI::ST_SUBMIT_ORDER& stsubmitorder() const;
  ::MEOrderAPI::ST_SUBMIT_ORDER* release_stsubmitorder();
  ::MEOrderAPI::ST_SUBMIT_ORDER* mutable_stsubmitorder();
  void set_allocated_stsubmitorder(::MEOrderAPI::ST_SUBMIT_ORDER* stsubmitorder);

  // .MEOrderAPI.ST_SUBMIT_CAMCEL_ORDER stCancelOrder = 7;
  bool has_stcancelorder() const;
  void clear_stcancelorder();
  static const int kStCancelOrderFieldNumber = 7;
  const ::MEOrderAPI::ST_SUBMIT_CAMCEL_ORDER& stcancelorder() const;
  ::MEOrderAPI::ST_SUBMIT_CAMCEL_ORDER* release_stcancelorder();
  ::MEOrderAPI::ST_SUBMIT_CAMCEL_ORDER* mutable_stcancelorder();
  void set_allocated_stcancelorder(::MEOrderAPI::ST_SUBMIT_CAMCEL_ORDER* stcancelorder);

  // .MEOrderAPI.ST_SUBMIT_ORDER_RESP stOrderResp = 8;
  bool has_storderresp() const;
  void clear_storderresp();
  static const int kStOrderRespFieldNumber = 8;
  const ::MEOrderAPI::ST_SUBMIT_ORDER_RESP& storderresp() const;
  ::MEOrderAPI::ST_SUBMIT_ORDER_RESP* release_storderresp();
  ::MEOrderAPI::ST_SUBMIT_ORDER_RESP* mutable_storderresp();
  void set_allocated_storderresp(::MEOrderAPI::ST_SUBMIT_ORDER_RESP* storderresp);

  // .MEOrderAPI.ST_QUERY_ORDER_INFO stQueryOrder = 9;
  bool has_stqueryorder() const;
  void clear_stqueryorder();
  static const int kStQueryOrderFieldNumber = 9;
  const ::MEOrderAPI::ST_QUERY_ORDER_INFO& stqueryorder() const;
  ::MEOrderAPI::ST_QUERY_ORDER_INFO* release_stqueryorder();
  ::MEOrderAPI::ST_QUERY_ORDER_INFO* mutable_stqueryorder();
  void set_allocated_stqueryorder(::MEOrderAPI::ST_QUERY_ORDER_INFO* stqueryorder);

  // .MEOrderAPI.ST_QUERY_ORDER_RES stQueryResp = 10;
  bool has_stqueryresp() const;
  void clear_stqueryresp();
  static const int kStQueryRespFieldNumber = 10;
  const ::MEOrderAPI::ST_QUERY_ORDER_RES& stqueryresp() const;
  ::MEOrderAPI::ST_QUERY_ORDER_RES* release_stqueryresp();
  ::MEOrderAPI::ST_QUERY_ORDER_RES* mutable_stqueryresp();
  void set_allocated_stqueryresp(::MEOrderAPI::ST_QUERY_ORDER_RES* stqueryresp);

  // .MESubcribeAPI.ST_TRANS_ORDER_INFO stTransOrder = 11;
  bool has_sttransorder() const;
  void clear_sttransorder();
  static const int kStTransOrderFieldNumber = 11;
  const ::MESubcribeAPI::ST_TRANS_ORDER_INFO& sttransorder() const;
  ::MESubcribeAPI::ST_TRANS_ORDER_INFO* release_sttransorder();
  ::MESubcribeAPI::ST_TRANS_ORDER_INFO* mutable_sttransorder();
  void set_allocated_sttransorder(::MESubcribeAPI::ST_TRANS_ORDER_INFO* sttransorder);

  // .MESubcribeAPI.ST_MART_QUOTATION stMarketData = 12;
  bool has_stmarketdata() const;
  void clear_stmarketdata();
  static const int kStMarketDataFieldNumber = 12;
  const ::MESubcribeAPI::ST_MART_QUOTATION& stmarketdata() const;
  ::MESubcribeAPI::ST_MART_QUOTATION* release_stmarketdata();
  ::MESubcribeAPI::ST_MART_QUOTATION* mutable_stmarketdata();
  void set_allocated_stmarketdata(::MESubcribeAPI::ST_MART_QUOTATION* stmarketdata);

  // .MESubcribeAPI.ST_REP_TRANS_ORDER_REQUEST stReptransReq = 13;
  bool has_streptransreq() const;
  void clear_streptransreq();
  static const int kStReptransReqFieldNumber = 13;
  const ::MESubcribeAPI::ST_REP_TRANS_ORDER_REQUEST& streptransreq() const;
  ::MESubcribeAPI::ST_REP_TRANS_ORDER_REQUEST* release_streptransreq();
  ::MESubcribeAPI::ST_REP_TRANS_ORDER_REQUEST* mutable_streptransreq();
  void set_allocated_streptransreq(::MESubcribeAPI::ST_REP_TRANS_ORDER_REQUEST* streptransreq);

  // .MEAuth.ST_USER_LOGIN_INFO stSubcriUserLogin = 14;
  bool has_stsubcriuserlogin() const;
  void clear_stsubcriuserlogin();
  static const int kStSubcriUserLoginFieldNumber = 14;
  const ::MEAuth::ST_USER_LOGIN_INFO& stsubcriuserlogin() const;
  ::MEAuth::ST_USER_LOGIN_INFO* release_stsubcriuserlogin();
  ::MEAuth::ST_USER_LOGIN_INFO* mutable_stsubcriuserlogin();
  void set_allocated_stsubcriuserlogin(::MEAuth::ST_USER_LOGIN_INFO* stsubcriuserlogin);

  // .MEOrderAPI.ST_QUERY_ORDER_INFO stQueryHistoryOrder = 15;
  bool has_stqueryhistoryorder() const;
  void clear_stqueryhistoryorder();
  static const int kStQueryHistoryOrderFieldNumber = 15;
  const ::MEOrderAPI::ST_QUERY_ORDER_INFO& stqueryhistoryorder() const;
  ::MEOrderAPI::ST_QUERY_ORDER_INFO* release_stqueryhistoryorder();
  ::MEOrderAPI::ST_QUERY_ORDER_INFO* mutable_stqueryhistoryorder();
  void set_allocated_stqueryhistoryorder(::MEOrderAPI::ST_QUERY_ORDER_INFO* stqueryhistoryorder);

  MsgBodyCase MsgBody_case() const;
  // @@protoc_insertion_point(class_scope:MEProInterface.IntervalMsgHeader)
 private:
  void set_has_stuserlogin();
  void set_has_stloginresp();
  void set_has_stsubmitorder();
  void set_has_stcancelorder();
  void set_has_storderresp();
  void set_has_stqueryorder();
  void set_has_stqueryresp();
  void set_has_sttransorder();
  void set_has_stmarketdata();
  void set_has_streptransreq();
  void set_has_stsubcriuserlogin();
  void set_has_stqueryhistoryorder();

  inline bool has_MsgBody() const;
  void clear_MsgBody();
  inline void clear_has_MsgBody();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 iflownumber_;
  ::google::protobuf::int32 icmd_;
  ::google::protobuf::int32 imsgtype_;
  union MsgBodyUnion {
    MsgBodyUnion() {}
    ::MEAuth::ST_USER_LOGIN_INFO* stuserlogin_;
    ::MEAuth::ST_USER_LOGIN_RESP* stloginresp_;
    ::MEOrderAPI::ST_SUBMIT_ORDER* stsubmitorder_;
    ::MEOrderAPI::ST_SUBMIT_CAMCEL_ORDER* stcancelorder_;
    ::MEOrderAPI::ST_SUBMIT_ORDER_RESP* storderresp_;
    ::MEOrderAPI::ST_QUERY_ORDER_INFO* stqueryorder_;
    ::MEOrderAPI::ST_QUERY_ORDER_RES* stqueryresp_;
    ::MESubcribeAPI::ST_TRANS_ORDER_INFO* sttransorder_;
    ::MESubcribeAPI::ST_MART_QUOTATION* stmarketdata_;
    ::MESubcribeAPI::ST_REP_TRANS_ORDER_REQUEST* streptransreq_;
    ::MEAuth::ST_USER_LOGIN_INFO* stsubcriuserlogin_;
    ::MEOrderAPI::ST_QUERY_ORDER_INFO* stqueryhistoryorder_;
  } MsgBody_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_ME_2eInterface_2eproto::TableStruct;
  friend void ::protobuf_ME_2eInterface_2eproto::InitDefaultsIntervalMsgHeaderImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// IntervalMsgHeader

// int32 iFlowNumber = 1;
inline void IntervalMsgHeader::clear_iflownumber() {
  iflownumber_ = 0;
}
inline ::google::protobuf::int32 IntervalMsgHeader::iflownumber() const {
  // @@protoc_insertion_point(field_get:MEProInterface.IntervalMsgHeader.iFlowNumber)
  return iflownumber_;
}
inline void IntervalMsgHeader::set_iflownumber(::google::protobuf::int32 value) {
  
  iflownumber_ = value;
  // @@protoc_insertion_point(field_set:MEProInterface.IntervalMsgHeader.iFlowNumber)
}

// int32 iCmd = 2;
inline void IntervalMsgHeader::clear_icmd() {
  icmd_ = 0;
}
inline ::google::protobuf::int32 IntervalMsgHeader::icmd() const {
  // @@protoc_insertion_point(field_get:MEProInterface.IntervalMsgHeader.iCmd)
  return icmd_;
}
inline void IntervalMsgHeader::set_icmd(::google::protobuf::int32 value) {
  
  icmd_ = value;
  // @@protoc_insertion_point(field_set:MEProInterface.IntervalMsgHeader.iCmd)
}

// int32 iMsgType = 3;
inline void IntervalMsgHeader::clear_imsgtype() {
  imsgtype_ = 0;
}
inline ::google::protobuf::int32 IntervalMsgHeader::imsgtype() const {
  // @@protoc_insertion_point(field_get:MEProInterface.IntervalMsgHeader.iMsgType)
  return imsgtype_;
}
inline void IntervalMsgHeader::set_imsgtype(::google::protobuf::int32 value) {
  
  imsgtype_ = value;
  // @@protoc_insertion_point(field_set:MEProInterface.IntervalMsgHeader.iMsgType)
}

// .MEAuth.ST_USER_LOGIN_INFO stUserLogin = 4;
inline bool IntervalMsgHeader::has_stuserlogin() const {
  return MsgBody_case() == kStUserLogin;
}
inline void IntervalMsgHeader::set_has_stuserlogin() {
  _oneof_case_[0] = kStUserLogin;
}
inline ::MEAuth::ST_USER_LOGIN_INFO* IntervalMsgHeader::release_stuserlogin() {
  // @@protoc_insertion_point(field_release:MEProInterface.IntervalMsgHeader.stUserLogin)
  if (has_stuserlogin()) {
    clear_has_MsgBody();
      ::MEAuth::ST_USER_LOGIN_INFO* temp = MsgBody_.stuserlogin_;
    MsgBody_.stuserlogin_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::MEAuth::ST_USER_LOGIN_INFO& IntervalMsgHeader::stuserlogin() const {
  // @@protoc_insertion_point(field_get:MEProInterface.IntervalMsgHeader.stUserLogin)
  return has_stuserlogin()
      ? *MsgBody_.stuserlogin_
      : *reinterpret_cast< ::MEAuth::ST_USER_LOGIN_INFO*>(&::MEAuth::_ST_USER_LOGIN_INFO_default_instance_);
}
inline ::MEAuth::ST_USER_LOGIN_INFO* IntervalMsgHeader::mutable_stuserlogin() {
  if (!has_stuserlogin()) {
    clear_MsgBody();
    set_has_stuserlogin();
    MsgBody_.stuserlogin_ = new ::MEAuth::ST_USER_LOGIN_INFO;
  }
  // @@protoc_insertion_point(field_mutable:MEProInterface.IntervalMsgHeader.stUserLogin)
  return MsgBody_.stuserlogin_;
}

// .MEAuth.ST_USER_LOGIN_RESP stLoginResp = 5;
inline bool IntervalMsgHeader::has_stloginresp() const {
  return MsgBody_case() == kStLoginResp;
}
inline void IntervalMsgHeader::set_has_stloginresp() {
  _oneof_case_[0] = kStLoginResp;
}
inline ::MEAuth::ST_USER_LOGIN_RESP* IntervalMsgHeader::release_stloginresp() {
  // @@protoc_insertion_point(field_release:MEProInterface.IntervalMsgHeader.stLoginResp)
  if (has_stloginresp()) {
    clear_has_MsgBody();
      ::MEAuth::ST_USER_LOGIN_RESP* temp = MsgBody_.stloginresp_;
    MsgBody_.stloginresp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::MEAuth::ST_USER_LOGIN_RESP& IntervalMsgHeader::stloginresp() const {
  // @@protoc_insertion_point(field_get:MEProInterface.IntervalMsgHeader.stLoginResp)
  return has_stloginresp()
      ? *MsgBody_.stloginresp_
      : *reinterpret_cast< ::MEAuth::ST_USER_LOGIN_RESP*>(&::MEAuth::_ST_USER_LOGIN_RESP_default_instance_);
}
inline ::MEAuth::ST_USER_LOGIN_RESP* IntervalMsgHeader::mutable_stloginresp() {
  if (!has_stloginresp()) {
    clear_MsgBody();
    set_has_stloginresp();
    MsgBody_.stloginresp_ = new ::MEAuth::ST_USER_LOGIN_RESP;
  }
  // @@protoc_insertion_point(field_mutable:MEProInterface.IntervalMsgHeader.stLoginResp)
  return MsgBody_.stloginresp_;
}

// .MEOrderAPI.ST_SUBMIT_ORDER stSubmitOrder = 6;
inline bool IntervalMsgHeader::has_stsubmitorder() const {
  return MsgBody_case() == kStSubmitOrder;
}
inline void IntervalMsgHeader::set_has_stsubmitorder() {
  _oneof_case_[0] = kStSubmitOrder;
}
inline ::MEOrderAPI::ST_SUBMIT_ORDER* IntervalMsgHeader::release_stsubmitorder() {
  // @@protoc_insertion_point(field_release:MEProInterface.IntervalMsgHeader.stSubmitOrder)
  if (has_stsubmitorder()) {
    clear_has_MsgBody();
      ::MEOrderAPI::ST_SUBMIT_ORDER* temp = MsgBody_.stsubmitorder_;
    MsgBody_.stsubmitorder_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::MEOrderAPI::ST_SUBMIT_ORDER& IntervalMsgHeader::stsubmitorder() const {
  // @@protoc_insertion_point(field_get:MEProInterface.IntervalMsgHeader.stSubmitOrder)
  return has_stsubmitorder()
      ? *MsgBody_.stsubmitorder_
      : *reinterpret_cast< ::MEOrderAPI::ST_SUBMIT_ORDER*>(&::MEOrderAPI::_ST_SUBMIT_ORDER_default_instance_);
}
inline ::MEOrderAPI::ST_SUBMIT_ORDER* IntervalMsgHeader::mutable_stsubmitorder() {
  if (!has_stsubmitorder()) {
    clear_MsgBody();
    set_has_stsubmitorder();
    MsgBody_.stsubmitorder_ = new ::MEOrderAPI::ST_SUBMIT_ORDER;
  }
  // @@protoc_insertion_point(field_mutable:MEProInterface.IntervalMsgHeader.stSubmitOrder)
  return MsgBody_.stsubmitorder_;
}

// .MEOrderAPI.ST_SUBMIT_CAMCEL_ORDER stCancelOrder = 7;
inline bool IntervalMsgHeader::has_stcancelorder() const {
  return MsgBody_case() == kStCancelOrder;
}
inline void IntervalMsgHeader::set_has_stcancelorder() {
  _oneof_case_[0] = kStCancelOrder;
}
inline ::MEOrderAPI::ST_SUBMIT_CAMCEL_ORDER* IntervalMsgHeader::release_stcancelorder() {
  // @@protoc_insertion_point(field_release:MEProInterface.IntervalMsgHeader.stCancelOrder)
  if (has_stcancelorder()) {
    clear_has_MsgBody();
      ::MEOrderAPI::ST_SUBMIT_CAMCEL_ORDER* temp = MsgBody_.stcancelorder_;
    MsgBody_.stcancelorder_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::MEOrderAPI::ST_SUBMIT_CAMCEL_ORDER& IntervalMsgHeader::stcancelorder() const {
  // @@protoc_insertion_point(field_get:MEProInterface.IntervalMsgHeader.stCancelOrder)
  return has_stcancelorder()
      ? *MsgBody_.stcancelorder_
      : *reinterpret_cast< ::MEOrderAPI::ST_SUBMIT_CAMCEL_ORDER*>(&::MEOrderAPI::_ST_SUBMIT_CAMCEL_ORDER_default_instance_);
}
inline ::MEOrderAPI::ST_SUBMIT_CAMCEL_ORDER* IntervalMsgHeader::mutable_stcancelorder() {
  if (!has_stcancelorder()) {
    clear_MsgBody();
    set_has_stcancelorder();
    MsgBody_.stcancelorder_ = new ::MEOrderAPI::ST_SUBMIT_CAMCEL_ORDER;
  }
  // @@protoc_insertion_point(field_mutable:MEProInterface.IntervalMsgHeader.stCancelOrder)
  return MsgBody_.stcancelorder_;
}

// .MEOrderAPI.ST_SUBMIT_ORDER_RESP stOrderResp = 8;
inline bool IntervalMsgHeader::has_storderresp() const {
  return MsgBody_case() == kStOrderResp;
}
inline void IntervalMsgHeader::set_has_storderresp() {
  _oneof_case_[0] = kStOrderResp;
}
inline ::MEOrderAPI::ST_SUBMIT_ORDER_RESP* IntervalMsgHeader::release_storderresp() {
  // @@protoc_insertion_point(field_release:MEProInterface.IntervalMsgHeader.stOrderResp)
  if (has_storderresp()) {
    clear_has_MsgBody();
      ::MEOrderAPI::ST_SUBMIT_ORDER_RESP* temp = MsgBody_.storderresp_;
    MsgBody_.storderresp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::MEOrderAPI::ST_SUBMIT_ORDER_RESP& IntervalMsgHeader::storderresp() const {
  // @@protoc_insertion_point(field_get:MEProInterface.IntervalMsgHeader.stOrderResp)
  return has_storderresp()
      ? *MsgBody_.storderresp_
      : *reinterpret_cast< ::MEOrderAPI::ST_SUBMIT_ORDER_RESP*>(&::MEOrderAPI::_ST_SUBMIT_ORDER_RESP_default_instance_);
}
inline ::MEOrderAPI::ST_SUBMIT_ORDER_RESP* IntervalMsgHeader::mutable_storderresp() {
  if (!has_storderresp()) {
    clear_MsgBody();
    set_has_storderresp();
    MsgBody_.storderresp_ = new ::MEOrderAPI::ST_SUBMIT_ORDER_RESP;
  }
  // @@protoc_insertion_point(field_mutable:MEProInterface.IntervalMsgHeader.stOrderResp)
  return MsgBody_.storderresp_;
}

// .MEOrderAPI.ST_QUERY_ORDER_INFO stQueryOrder = 9;
inline bool IntervalMsgHeader::has_stqueryorder() const {
  return MsgBody_case() == kStQueryOrder;
}
inline void IntervalMsgHeader::set_has_stqueryorder() {
  _oneof_case_[0] = kStQueryOrder;
}
inline ::MEOrderAPI::ST_QUERY_ORDER_INFO* IntervalMsgHeader::release_stqueryorder() {
  // @@protoc_insertion_point(field_release:MEProInterface.IntervalMsgHeader.stQueryOrder)
  if (has_stqueryorder()) {
    clear_has_MsgBody();
      ::MEOrderAPI::ST_QUERY_ORDER_INFO* temp = MsgBody_.stqueryorder_;
    MsgBody_.stqueryorder_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::MEOrderAPI::ST_QUERY_ORDER_INFO& IntervalMsgHeader::stqueryorder() const {
  // @@protoc_insertion_point(field_get:MEProInterface.IntervalMsgHeader.stQueryOrder)
  return has_stqueryorder()
      ? *MsgBody_.stqueryorder_
      : *reinterpret_cast< ::MEOrderAPI::ST_QUERY_ORDER_INFO*>(&::MEOrderAPI::_ST_QUERY_ORDER_INFO_default_instance_);
}
inline ::MEOrderAPI::ST_QUERY_ORDER_INFO* IntervalMsgHeader::mutable_stqueryorder() {
  if (!has_stqueryorder()) {
    clear_MsgBody();
    set_has_stqueryorder();
    MsgBody_.stqueryorder_ = new ::MEOrderAPI::ST_QUERY_ORDER_INFO;
  }
  // @@protoc_insertion_point(field_mutable:MEProInterface.IntervalMsgHeader.stQueryOrder)
  return MsgBody_.stqueryorder_;
}

// .MEOrderAPI.ST_QUERY_ORDER_RES stQueryResp = 10;
inline bool IntervalMsgHeader::has_stqueryresp() const {
  return MsgBody_case() == kStQueryResp;
}
inline void IntervalMsgHeader::set_has_stqueryresp() {
  _oneof_case_[0] = kStQueryResp;
}
inline ::MEOrderAPI::ST_QUERY_ORDER_RES* IntervalMsgHeader::release_stqueryresp() {
  // @@protoc_insertion_point(field_release:MEProInterface.IntervalMsgHeader.stQueryResp)
  if (has_stqueryresp()) {
    clear_has_MsgBody();
      ::MEOrderAPI::ST_QUERY_ORDER_RES* temp = MsgBody_.stqueryresp_;
    MsgBody_.stqueryresp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::MEOrderAPI::ST_QUERY_ORDER_RES& IntervalMsgHeader::stqueryresp() const {
  // @@protoc_insertion_point(field_get:MEProInterface.IntervalMsgHeader.stQueryResp)
  return has_stqueryresp()
      ? *MsgBody_.stqueryresp_
      : *reinterpret_cast< ::MEOrderAPI::ST_QUERY_ORDER_RES*>(&::MEOrderAPI::_ST_QUERY_ORDER_RES_default_instance_);
}
inline ::MEOrderAPI::ST_QUERY_ORDER_RES* IntervalMsgHeader::mutable_stqueryresp() {
  if (!has_stqueryresp()) {
    clear_MsgBody();
    set_has_stqueryresp();
    MsgBody_.stqueryresp_ = new ::MEOrderAPI::ST_QUERY_ORDER_RES;
  }
  // @@protoc_insertion_point(field_mutable:MEProInterface.IntervalMsgHeader.stQueryResp)
  return MsgBody_.stqueryresp_;
}

// .MESubcribeAPI.ST_TRANS_ORDER_INFO stTransOrder = 11;
inline bool IntervalMsgHeader::has_sttransorder() const {
  return MsgBody_case() == kStTransOrder;
}
inline void IntervalMsgHeader::set_has_sttransorder() {
  _oneof_case_[0] = kStTransOrder;
}
inline ::MESubcribeAPI::ST_TRANS_ORDER_INFO* IntervalMsgHeader::release_sttransorder() {
  // @@protoc_insertion_point(field_release:MEProInterface.IntervalMsgHeader.stTransOrder)
  if (has_sttransorder()) {
    clear_has_MsgBody();
      ::MESubcribeAPI::ST_TRANS_ORDER_INFO* temp = MsgBody_.sttransorder_;
    MsgBody_.sttransorder_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::MESubcribeAPI::ST_TRANS_ORDER_INFO& IntervalMsgHeader::sttransorder() const {
  // @@protoc_insertion_point(field_get:MEProInterface.IntervalMsgHeader.stTransOrder)
  return has_sttransorder()
      ? *MsgBody_.sttransorder_
      : *reinterpret_cast< ::MESubcribeAPI::ST_TRANS_ORDER_INFO*>(&::MESubcribeAPI::_ST_TRANS_ORDER_INFO_default_instance_);
}
inline ::MESubcribeAPI::ST_TRANS_ORDER_INFO* IntervalMsgHeader::mutable_sttransorder() {
  if (!has_sttransorder()) {
    clear_MsgBody();
    set_has_sttransorder();
    MsgBody_.sttransorder_ = new ::MESubcribeAPI::ST_TRANS_ORDER_INFO;
  }
  // @@protoc_insertion_point(field_mutable:MEProInterface.IntervalMsgHeader.stTransOrder)
  return MsgBody_.sttransorder_;
}

// .MESubcribeAPI.ST_MART_QUOTATION stMarketData = 12;
inline bool IntervalMsgHeader::has_stmarketdata() const {
  return MsgBody_case() == kStMarketData;
}
inline void IntervalMsgHeader::set_has_stmarketdata() {
  _oneof_case_[0] = kStMarketData;
}
inline ::MESubcribeAPI::ST_MART_QUOTATION* IntervalMsgHeader::release_stmarketdata() {
  // @@protoc_insertion_point(field_release:MEProInterface.IntervalMsgHeader.stMarketData)
  if (has_stmarketdata()) {
    clear_has_MsgBody();
      ::MESubcribeAPI::ST_MART_QUOTATION* temp = MsgBody_.stmarketdata_;
    MsgBody_.stmarketdata_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::MESubcribeAPI::ST_MART_QUOTATION& IntervalMsgHeader::stmarketdata() const {
  // @@protoc_insertion_point(field_get:MEProInterface.IntervalMsgHeader.stMarketData)
  return has_stmarketdata()
      ? *MsgBody_.stmarketdata_
      : *reinterpret_cast< ::MESubcribeAPI::ST_MART_QUOTATION*>(&::MESubcribeAPI::_ST_MART_QUOTATION_default_instance_);
}
inline ::MESubcribeAPI::ST_MART_QUOTATION* IntervalMsgHeader::mutable_stmarketdata() {
  if (!has_stmarketdata()) {
    clear_MsgBody();
    set_has_stmarketdata();
    MsgBody_.stmarketdata_ = new ::MESubcribeAPI::ST_MART_QUOTATION;
  }
  // @@protoc_insertion_point(field_mutable:MEProInterface.IntervalMsgHeader.stMarketData)
  return MsgBody_.stmarketdata_;
}

// .MESubcribeAPI.ST_REP_TRANS_ORDER_REQUEST stReptransReq = 13;
inline bool IntervalMsgHeader::has_streptransreq() const {
  return MsgBody_case() == kStReptransReq;
}
inline void IntervalMsgHeader::set_has_streptransreq() {
  _oneof_case_[0] = kStReptransReq;
}
inline ::MESubcribeAPI::ST_REP_TRANS_ORDER_REQUEST* IntervalMsgHeader::release_streptransreq() {
  // @@protoc_insertion_point(field_release:MEProInterface.IntervalMsgHeader.stReptransReq)
  if (has_streptransreq()) {
    clear_has_MsgBody();
      ::MESubcribeAPI::ST_REP_TRANS_ORDER_REQUEST* temp = MsgBody_.streptransreq_;
    MsgBody_.streptransreq_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::MESubcribeAPI::ST_REP_TRANS_ORDER_REQUEST& IntervalMsgHeader::streptransreq() const {
  // @@protoc_insertion_point(field_get:MEProInterface.IntervalMsgHeader.stReptransReq)
  return has_streptransreq()
      ? *MsgBody_.streptransreq_
      : *reinterpret_cast< ::MESubcribeAPI::ST_REP_TRANS_ORDER_REQUEST*>(&::MESubcribeAPI::_ST_REP_TRANS_ORDER_REQUEST_default_instance_);
}
inline ::MESubcribeAPI::ST_REP_TRANS_ORDER_REQUEST* IntervalMsgHeader::mutable_streptransreq() {
  if (!has_streptransreq()) {
    clear_MsgBody();
    set_has_streptransreq();
    MsgBody_.streptransreq_ = new ::MESubcribeAPI::ST_REP_TRANS_ORDER_REQUEST;
  }
  // @@protoc_insertion_point(field_mutable:MEProInterface.IntervalMsgHeader.stReptransReq)
  return MsgBody_.streptransreq_;
}

// .MEAuth.ST_USER_LOGIN_INFO stSubcriUserLogin = 14;
inline bool IntervalMsgHeader::has_stsubcriuserlogin() const {
  return MsgBody_case() == kStSubcriUserLogin;
}
inline void IntervalMsgHeader::set_has_stsubcriuserlogin() {
  _oneof_case_[0] = kStSubcriUserLogin;
}
inline ::MEAuth::ST_USER_LOGIN_INFO* IntervalMsgHeader::release_stsubcriuserlogin() {
  // @@protoc_insertion_point(field_release:MEProInterface.IntervalMsgHeader.stSubcriUserLogin)
  if (has_stsubcriuserlogin()) {
    clear_has_MsgBody();
      ::MEAuth::ST_USER_LOGIN_INFO* temp = MsgBody_.stsubcriuserlogin_;
    MsgBody_.stsubcriuserlogin_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::MEAuth::ST_USER_LOGIN_INFO& IntervalMsgHeader::stsubcriuserlogin() const {
  // @@protoc_insertion_point(field_get:MEProInterface.IntervalMsgHeader.stSubcriUserLogin)
  return has_stsubcriuserlogin()
      ? *MsgBody_.stsubcriuserlogin_
      : *reinterpret_cast< ::MEAuth::ST_USER_LOGIN_INFO*>(&::MEAuth::_ST_USER_LOGIN_INFO_default_instance_);
}
inline ::MEAuth::ST_USER_LOGIN_INFO* IntervalMsgHeader::mutable_stsubcriuserlogin() {
  if (!has_stsubcriuserlogin()) {
    clear_MsgBody();
    set_has_stsubcriuserlogin();
    MsgBody_.stsubcriuserlogin_ = new ::MEAuth::ST_USER_LOGIN_INFO;
  }
  // @@protoc_insertion_point(field_mutable:MEProInterface.IntervalMsgHeader.stSubcriUserLogin)
  return MsgBody_.stsubcriuserlogin_;
}

// .MEOrderAPI.ST_QUERY_ORDER_INFO stQueryHistoryOrder = 15;
inline bool IntervalMsgHeader::has_stqueryhistoryorder() const {
  return MsgBody_case() == kStQueryHistoryOrder;
}
inline void IntervalMsgHeader::set_has_stqueryhistoryorder() {
  _oneof_case_[0] = kStQueryHistoryOrder;
}
inline ::MEOrderAPI::ST_QUERY_ORDER_INFO* IntervalMsgHeader::release_stqueryhistoryorder() {
  // @@protoc_insertion_point(field_release:MEProInterface.IntervalMsgHeader.stQueryHistoryOrder)
  if (has_stqueryhistoryorder()) {
    clear_has_MsgBody();
      ::MEOrderAPI::ST_QUERY_ORDER_INFO* temp = MsgBody_.stqueryhistoryorder_;
    MsgBody_.stqueryhistoryorder_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::MEOrderAPI::ST_QUERY_ORDER_INFO& IntervalMsgHeader::stqueryhistoryorder() const {
  // @@protoc_insertion_point(field_get:MEProInterface.IntervalMsgHeader.stQueryHistoryOrder)
  return has_stqueryhistoryorder()
      ? *MsgBody_.stqueryhistoryorder_
      : *reinterpret_cast< ::MEOrderAPI::ST_QUERY_ORDER_INFO*>(&::MEOrderAPI::_ST_QUERY_ORDER_INFO_default_instance_);
}
inline ::MEOrderAPI::ST_QUERY_ORDER_INFO* IntervalMsgHeader::mutable_stqueryhistoryorder() {
  if (!has_stqueryhistoryorder()) {
    clear_MsgBody();
    set_has_stqueryhistoryorder();
    MsgBody_.stqueryhistoryorder_ = new ::MEOrderAPI::ST_QUERY_ORDER_INFO;
  }
  // @@protoc_insertion_point(field_mutable:MEProInterface.IntervalMsgHeader.stQueryHistoryOrder)
  return MsgBody_.stqueryhistoryorder_;
}

inline bool IntervalMsgHeader::has_MsgBody() const {
  return MsgBody_case() != MSGBODY_NOT_SET;
}
inline void IntervalMsgHeader::clear_has_MsgBody() {
  _oneof_case_[0] = MSGBODY_NOT_SET;
}
inline IntervalMsgHeader::MsgBodyCase IntervalMsgHeader::MsgBody_case() const {
  return IntervalMsgHeader::MsgBodyCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace MEProInterface

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ME_2eInterface_2eproto__INCLUDED
